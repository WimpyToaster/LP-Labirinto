%%%%%%%%%%%%%%%%%%%%%%%%
%      Projeto!!!!!    %
%%%%%%%%%%%%%%%%%%%%%%%%

%Funcoes auxiliares:

%recebe lista de listas, devolve uma lista com todos os elementos.    
flat_list(X, [X]) :- \+is_list(X).
flat_list([], []).
flat_list([H | B], Lout) :- flat_list(H, Elem1),
							flat_list(B, Elem2),
							append(Elem1, Elem2, Lout).







%Retorna true ou false respetivamente se um elemento esta ou nao nessa lista.
ha_elem([],[]).
ha_elem([X | _ ], X).
ha_elem([ _ | B], X) :- ha_elem(B, X).   
	





	
%Retorna o elemento da lista na posicao n. A primeira posicao e' 1.
elem_lista([X | _ ], 1, X).
elem_lista([ _ | B], Pos, Elem) :- Pos1 is Pos - 1,
									elem_lista(B, Pos1, Elem).





														
%Retorna o elemento nas coordenadas (X,Y). O primeiro elemento tem cordenadas (1,1).														
elem_matriz(Matriz, (CoorX, CoorY), Elem_Out) :- elem_lista(Matriz, CoorX, Linha),
												 elem_lista(Linha, CoorY, Elem_Out).






%Recebe uma lista com as um subconjunto da seguinte lista: [c,b,e,d]. Nao inclui ela propria e elementos podem estar permutados.																					  
%Retorna a lista "inversa". 

direcao_possivel([X], Y) :- remove_elem([c,b,e,d], X, Y).
direcao_possivel([H | B], L_Out) :- direcao_possivel(B, Aux_Out),
								   remove_elem(Aux_Out, H, L_Out).






%remove um elemento de uma lista
remove_elem([X], Elem, []) :- X == Elem.
remove_elem([X], Elem, [X]) :- X \== Elem.
remove_elem([H | B], Elem, L_Out) :- Elem == H,
									remove_elem(B, Elem, L_Out).
remove_elem([H | B], Elem, L_Out) :- Elem \== H,
									remove_elem(B, Elem, Aux),
									append([H], Aux, L_Out).




															
%construtor de um movimento
constroi_mov(D, (X,Y), Mov) :- Mov = (D, X, Y).

/*dada uma lista com direcoes e uma coordenada devolve uma lista com as jogadas*/

faz_jogada(['c'], (X,Y), L_Out) :- X1 is X - 1, constroi_mov(c, (X1,Y), L_Out).
faz_jogada(['b'], (X,Y), L_Out) :- X1 is X + 1, constroi_mov(b, (X1,Y), L_Out).
faz_jogada(['e'], (X,Y), L_Out) :- Y1 is Y - 1, constroi_mov(e, (X,Y1), L_Out).
faz_jogada(['d'], (X,Y), L_Out) :- Y1 is Y + 1, constroi_mov(d, (X,Y1), L_Out).
faz_jogada([H | B], (X, Y), L_Out) :- faz_jogada(B, (X,Y), Aux),
									  faz_jogada([H], (X,Y), Mov),
									  append([Mov], [Aux], L_Out).

/*Funcoes principais:		movs_possiveis(LABIRINTO //  POSICAO ATUAL // MOVIMENTOS // MOVIMENTOS POSSIVEIS)
*/
movs_possiveis(Lab, (X,Y), [X], )
movs_possiveis(Lab, (X,Y), [H | B], Poss) :- elem_matriz(Lab, (X,Y), Celula),
                                             direcao_possivel(Celula, L_Dir_Poss),
                                             ha_elem(L_Dir_Poss, H),
                                             movs_possiveis(Lab, (X,Y), B, Poss).
movs_possiveis(Lab, (X,Y), [H | B], Poss) :- elem_matriz(Lab, (X,Y), Celula),
                                             direcao_possivel(Celula, L_Dir_Poss),
                                             \+ha_elem(L_Dir_Poss, H),
                                             movs_possiveis(Lab, (X,Y), B, Aux),
                                             append(H, Aux, Poss).

/*distancia de dois pontos */
distancia((L1,C1),(L2,C2),Dist):- Dist is abs(L1-L2) + abs(C1-C2).

%devolve o valor da posicao do tuple de um movimento
segundo_tuple((_, Y, _), Out) :- Out is Y.
terceiro_tuple((_, _, Z), Out) :- Out is Z. 

%compara qual o movimento com menor distancia ao final, ou maior distancia ao inicio
 menor(X, Y, _, Pos_final, Out) :- segundo_tuple(X, L1), terceiro_tuple(X, C1), 
                                                                       segundo_tuple(Y, L2), terceiro_tuple(Y, C2),
                                                                       distancia( (L1,C1), Pos_final, S1),
                                                                       distancia( (L2, C2), Pos_final, S2),
                                                                       S1 < S2, Out = X.
 menor(X, Y, _, Pos_final, Out) :- segundo_tuple(X, L1), terceiro_tuple(X, C1), 
                                                                       segundo_tuple(Y, L2), terceiro_tuple(Y, C2),
                                                                       distancia( (L1,C1), Pos_final, S1),
                                                                       distancia( (L2, C2), Pos_final, S2),
                                                                       S2 < S1, Out = Y.                                                                   
 menor(X, Y, Pos_inicial, Pos_final, Out) :- segundo_tuple(X, L1), terceiro_tuple(X, C1), 
                                                                       segundo_tuple(Y, L2), terceiro_tuple(Y, C2),
                                                                       distancia( (L1,C1), Pos_final, S1),
                                                                       distancia( (L2, C2), Pos_final, S2),
                                                                       S1 == S2, maior(X, Y, Pos_inicial, Pos_final, Out).
 maior(X, Y, Pos_inicial, _, Out) :- segundo_tuple(X, L1), terceiro_tuple(X, C1), 
                                                                       segundo_tuple(Y, L2), terceiro_tuple(Y, C2),
                                                                       distancia( (L1,C1), Pos_inicial, S1),
                                                                       distancia( (L2, C2), Pos_inicial, S2),
                                                                       S1 > S2, Out = X.
 maior(X, Y, Pos_inicial, _, Out) :- segundo_tuple(X, L1), terceiro_tuple(X, C1), 
                                                                       segundo_tuple(Y, L2), terceiro_tuple(Y, C2),
                                                                       distancia( (L1,C1), Pos_inicial, S1),
                                                                       distancia( (L2, C2), Pos_inicial, S2),
                                                                       S2 > S1, Out = Y.

%encotra o movimento minimos dos possiveis 
 encontra_min([H | B], Pos_inicial, Pos_final, Out) :- encontra_min(B, H, Pos_inicial, Pos_final, Out).
 encontra_min([C | T], Aux, Pos_inicial, Pos_final, Out) :- menor(C, Aux, Pos_inicial, Pos_final, Aux1),
                                                                                                 encontra_min(T, Aux1, Pos_inicial, Pos_final, Out).
 encontra_min([], Aux, _, _, Out) :- Out = Aux .

%ordena_poss(Possiveis,  Possiveis Ordenados, Pos inicial, Pos final)

ordena_poss(Poss, L_Out, Pos_inicial, Pos_final) :- encontra_min(), ordena_poss(Poss, L_Out, Pos_inicial, Pos_final, Aux).
ordena_poss(Poss, L_Out, Pos_inicial, Pos_final, Aux) :-  remove_elem(Poss, Aux , Poss1), ordena_poss(Poss1, L_Out1, Pos_inicial, Pos_final).

